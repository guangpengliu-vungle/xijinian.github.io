<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xijinian.top","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="从内部类到 Lambda123456789101112131415161718192021222324252627282930313233343536File f &#x3D; new File(&quot;.&quot;);&#x2F;&#x2F; 列出当前目录下的所有后缀为 .txt 的文件（内部类方式，通过传递接口，调用接口的方法）File[] files &#x3D; f.listFiles(new FilenameFilter()&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 8 函数式编程">
<meta property="og:url" content="https://www.xijinian.top/2019/01/23/Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Adventures of xijinian">
<meta property="og:description" content="从内部类到 Lambda123456789101112131415161718192021222324252627282930313233343536File f &#x3D; new File(&quot;.&quot;);&#x2F;&#x2F; 列出当前目录下的所有后缀为 .txt 的文件（内部类方式，通过传递接口，调用接口的方法）File[] files &#x3D; f.listFiles(new FilenameFilter()&amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/17/5Rn6wm1ZfXGTrk4.jpg">
<meta property="og:image" content="https://i.loli.net/2020/06/17/9IkN3BVxFPAXpqM.jpg">
<meta property="article:published_time" content="2019-01-22T16:54:27.000Z">
<meta property="article:modified_time" content="2020-06-22T17:01:31.000Z">
<meta property="article:author" content="xijinian">
<meta property="article:tag" content="Java 编程的逻辑">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/17/5Rn6wm1ZfXGTrk4.jpg">

<link rel="canonical" href="https://www.xijinian.top/2019/01/23/Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 8 函数式编程 | Adventures of xijinian</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adventures of xijinian</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xijinian" class="github-corner" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.xijinian.top/2019/01/23/Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="xijinian">
      <meta itemprop="description" content="放轻松，就像在漫游地球～">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adventures of xijinian">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 8 函数式编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-23 00:54:27" itemprop="dateCreated datePublished" datetime="2019-01-23T00:54:27+08:00">2019-01-23</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/01/23/Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/23/Java-8-函数式编程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="从内部类到-Lambda"><a href="#从内部类到-Lambda" class="headerlink" title="从内部类到 Lambda"></a>从内部类到 Lambda</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出当前目录下的所有后缀为 .txt 的文件（内部类方式，通过传递接口，调用接口的方法）</span></span><br><span class="line">File[] files = f.listFiles(<span class="keyword">new</span> FilenameFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// Lambda 方式</span></span><br><span class="line">File[] files = f.listFiles((File dir, String name) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> name.endsWith(<span class="string">".txt"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 方法体只有一行的时候，Lambda 可以省略 &#123;&#125; 和 return</span></span><br><span class="line">File[] files = f.listFiles((File dir, String name) -&gt; name.endsWith(<span class="string">".txt"</span>));</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 方法的参数类型声明也可以省略，因为 Java 可以自动推断出来，它知道 listFiles 接受的参数类型是 FilenameFilter</span></span><br><span class="line"><span class="comment">// 这个接口只有一个方法 accept，这个方法的两个参数类型分别是 File 和 String</span></span><br><span class="line">File[] files = f.listFiles((dir, name) -&gt; name.endsWith(<span class="string">".txt"</span>));</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * listFiles 还可以接受 FileFilter 的参数类型，FileFilter 只有一个参数</span></span><br><span class="line"><span class="comment"> **************************************</span></span><br><span class="line"><span class="comment"> * public interface FileFilter &#123;</span></span><br><span class="line"><span class="comment"> *     boolean accept(File pathname);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> **************************************</span></span><br><span class="line"><span class="comment"> * 当参数只有一个的时候，我们可以省略 Lambda 中的 ()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">File[] files = f.listFiles(path -&gt; path.getName().endsWith(<span class="string">".txt"</span>));</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, <span class="keyword">new</span> Comparator&lt;File&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(File f1, File f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.getName().compareTo(f2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line">executor.submit(() -&gt; System.out.println(<span class="string">"hello world"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="变量问题"><a href="#变量问题" class="headerlink" title="变量问题"></a>变量问题</h3><p>如下代码所示，与匿名内部类相仿，Lambda 表达式也会建立一个变量 <code>msg</code> 的副本，它的代码访问的是这个副本，而不是外部声明的 <code>msg</code> 变量。如果允许 <code>msg</code> 被修改，则程序员可能会误以为 Lambda 表达式会读到修改后的值，引起更多的混淆，因此这个变量不允许被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">"hello world"</span>;</span><br><span class="line">msg = <span class="string">"good morning"</span>; <span class="comment">// ×</span></span><br><span class="line">executor.submit(() -&gt; System.out.println(msg));</span><br></pre></td></tr></table></figure>
<p>建立变量 <code>msg</code> 的副本，是因为 <strong><code>msg</code> 定义在栈中，当 Lambda 表达式被执行的时候，<code>msg</code> 可能已被释放</strong>。<br>如果希望能够修改变量的值，可以将变量定义为实例变量，或者，将变量定义为数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] msg = <span class="keyword">new</span> String[]&#123;<span class="string">"hello world"</span>&#125;;</span><br><span class="line">msg[<span class="number">0</span>] = <span class="string">"good morning"</span>;</span><br><span class="line">executor.submit(() -&gt; System.out.println(msg[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="语法糖之虞"><a href="#语法糖之虞" class="headerlink" title="语法糖之虞"></a>语法糖之虞</h3><p>Lambda 表达式常常因为它简化了匿名内部类的表达，而被误认为是一种最终会转化为匿名内部类的语法糖，但事实并非如此。Java 会为每个匿名内部类生成一个类，但 Lambda 表达式不会，Lambda 表达式通常比较短，为每个表达式生成一个类会生成大量的类，性能会受到影响；Java 利用了 Java 7 引入的为支持动态类型语言引入的 <code>invokedynamic</code> 指令、方法句柄 (<code>method handle</code>) 等办法高效地实现了 Lambda。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>Lambda 不是匿名内部类，而是函数式接口。Lambda 表达式可以赋值给函数式接口，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileFilter filter = path -&gt; path.getName().endsWith(<span class="string">".txt"</span>);</span><br><span class="line">FilenameFilter fileNameFilter = (dir, name) -&gt; name.endsWith(<span class="string">".txt"</span>);</span><br><span class="line">Comparator&lt;File&gt; comparator = (f1, f2) -&gt; f1.getName().compareTo(f2.getName());</span><br><span class="line">Runnable task = () -&gt; System.out.println(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>

<p>函数式接口是只有一个抽象方法的接口，我们可以为它们添加一个 <code>@FunctionalInterface</code>  注解，来明确它是一个函数式接口，这个注解有限制抽象方法数量的功能，如果定义了多个抽象方法，会报错。</p>
<h3 id="预定义函数式接口"><a href="#预定义函数式接口" class="headerlink" title="预定义函数式接口"></a>预定义函数式接口</h3><p>函数式接口虽然很好，但一般不用自己定义，因为 Java 提供了一堆强大的预定义函数式接口，它们用法全面、命名考究、全局统一、不存歧义，没理由不首先使用它们。这些函数定义在包 <code>java.util.function</code> 下，主要的有：</p>
<p><img data-src="https://i.loli.net/2020/06/17/5Rn6wm1ZfXGTrk4.jpg" alt="924211-20170705204539409-168614794.jpg"></p>
<p>对于基本类型 <code>boolean</code>、<code>int</code>、<code>long</code> 和 <code>double</code>，为避免装箱 / 拆箱，还提供了对应类型的函数式接口，如：</p>
<p><img data-src="https://i.loli.net/2020/06/17/9IkN3BVxFPAXpqM.jpg" alt="924211-20170705204612909-86398551.jpg"></p>
<h4 id="Predicate-示例"><a href="#Predicate-示例" class="headerlink" title="Predicate 示例"></a><code>Predicate</code> 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">students = filter(students, t -&gt; t.getScore() &gt; <span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">filter</span><span class="params">(List&lt;E&gt; list, Predicate&lt;E&gt; pred)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; retList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (E e : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pred.test(e)) &#123;</span><br><span class="line">            retList.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function-示例"><a href="#Function-示例" class="headerlink" title="Function 示例"></a><code>Function</code> 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(students, t -&gt; t.getName());</span><br><span class="line">students = map(students, t -&gt; <span class="keyword">new</span> Student(t.getName().toUpperCase(), t.getScore()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; retList = <span class="keyword">new</span> ArrayList&lt;&gt;(list.size());</span><br><span class="line">    <span class="keyword">for</span> (T e : list) &#123;</span><br><span class="line">        retList.add(mapper.apply(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Consumer-示例"><a href="#Consumer-示例" class="headerlink" title="Consumer 示例"></a><code>Consumer</code> 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foreach(students, t -&gt; t.setName(t.getName().toUpperCase()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">(List&lt;E&gt; list, Consumer&lt;E&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E e : list) &#123;</span><br><span class="line">        consumer.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用 ::"></a>方法引用 <code>::</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(students, t -&gt; t.getName());</span><br><span class="line">↓ 等价于</span><br><span class="line">List&lt;String&gt; names = map(students, Student::getName);</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; s = Student::getCollegeName;</span><br><span class="line">↓ 等价于</span><br><span class="line">Supplier&lt;String&gt; s = () -&gt; Student.getCollegeName();</span><br></pre></td></tr></table></figure>

<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Student, String&gt; f = Student::getName;</span><br><span class="line">↓ 等价于</span><br><span class="line">Function&lt;Student, String&gt; f = (Student t) -&gt; t.getName();</span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Student, String&gt; c = Student::setName;</span><br><span class="line">↓ 等价于</span><br><span class="line">BiConsumer&lt;Student, String&gt; c = (t, name) -&gt; t.setName(name);</span><br></pre></td></tr></table></figure>

<h4 id="通过变量引用方法"><a href="#通过变量引用方法" class="headerlink" title="通过变量引用方法"></a>通过变量引用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果方法引用的第一部分是变量名，则相当于直接调用那个对象的方法，而实例方法时需要传递实例的</span></span><br><span class="line">Supplier&lt;String&gt; s = t::getName;</span><br><span class="line">↓ 等价于</span><br><span class="line">Supplier&lt;String&gt; s = () -&gt; t.getName();</span><br><span class="line"></span><br><span class="line">Consumer&lt;String&gt; consumer = t::setName;</span><br><span class="line">↓ 等价于</span><br><span class="line">Consumer&lt;String&gt; consumer = (name) -&gt; t.setName(name);</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, Double, Student&gt; s = Student::<span class="keyword">new</span>;</span><br><span class="line">↓ 等价于</span><br><span class="line">BiFunction&lt;String, Double, Student&gt; s = (name, score) -&gt; <span class="keyword">new</span> Student(name, score);</span><br></pre></td></tr></table></figure>

<h3 id="函数的复合"><a href="#函数的复合" class="headerlink" title="函数的复合"></a>函数的复合</h3><h4 id="Comparator-中的复合方法"><a href="#Comparator-中的复合方法" class="headerlink" title="Comparator 中的复合方法"></a><code>Comparator</code> 中的复合方法</h4><p><code>Comparator</code> 接口定义了如下静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(keyExtractor);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));</span><br><span class="line">↓ 等价于</span><br><span class="line">Arrays.sort(files, Comparator.comparing(File::getName));</span><br></pre></td></tr></table></figure>

<p><code>Comparator</code> 还有很多默认方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">        <span class="keyword">return</span> (res != <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.sort(Comparator.comparing(Student::getScore)</span><br><span class="line">                        .reversed()</span><br><span class="line">                        .thenComparing(Student::getName));</span><br></pre></td></tr></table></figure>

<h4 id="java-util-function-中的复合方法"><a href="#java-util-function-中的复合方法" class="headerlink" title="java.util.function 中的复合方法"></a><code>java.util.function</code> 中的复合方法</h4><p>用 <code>Function</code> 接口举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先将 T 类型的参数转化为类型 R，再调用 after 将 R 转换为 V，最后返回类型 V</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 V 类型的参数，先调用 before 将 V 转换为 T 类型，再调用当前的 apply 方法转换为 R 类型返回</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Stream-漫谈"><a href="#Stream-漫谈" class="headerlink" title="Stream 漫谈"></a><code>Stream</code> 漫谈</h3><p>接口 <code>Stream</code> 类似于一个迭代器，但提供了更为丰富的操作，<code>Stream</code> API 的主要操作就定义在该接口中。</p>
<p>Java 8 给 <code>Collection</code> 接口增加了两个默认方法，它们可以返回一个 <code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Arrays</code> 有一些 <code>stream</code> 方法，可以将数组或子数组转换为流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array, <span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Stream</code> 也有一些静态方法，可以构建流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个空流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回只包含一个元素 t 的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回包含多个元素 values 的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 通过 Supplier 生成流，流的元素个数是无限的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 同样生成无限流，第一个元素为 seed，第二个为 f(seed)，第三个为 f(f(seed))，依次类推</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>调用 <code>filter()</code> 和 <code>map()</code> 都不会执行任何实际的操作，它们只是在构建操作的流水线，调用 <code>collect</code> 才会触发实际的遍历执行，在一次遍历中完成过滤、转换以及收集结果的任务。像 <code>filter</code> 和 <code>map</code> 这种不实际触发执行、用于构建流水线、返回 <code>Stream</code> 的操作被称为中间操作 (intermediate operation)，而像 <code>collect</code> 这种触发实际执行、返回具体结果的操作被称为终端操作 (terminal operation)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(() -&gt; Math.random())</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream.iterate(<span class="number">1</span>, t -&gt; t + <span class="number">2</span>)</span><br><span class="line">    .limit(<span class="number">100</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><ul>
<li><p><code>distinct</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"hello"</span>,<span class="string">"Abc"</span>&#125;);</span><br><span class="line">List&lt;String&gt; retList = list.stream()</span><br><span class="line">        .filter(s -&gt; s.length() &lt;= <span class="number">3</span>)</span><br><span class="line">        .map(String::toLowerCase)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(retList);</span><br></pre></td></tr></table></figure>

<p><code>filter</code> 和 <code>map</code> 都是无状态的，对于流中的每一个元素，它的处理都是独立的，处理后即交给流水线中的下一个操作，但 <code>distinct</code> 不同，它是有状态的，在处理过程中，它需要在内部记录之前出现过的元素，如果已经出现过，即重复元素，它就会过滤掉，不传递给流水线中的下一个操作。对于顺序流，内部实现时，<code>distinct</code> 操作会使用 <code>HashSet</code> 记录出现过的元素，如果流是有顺序的，需要保留顺序，会使用 <code>LinkedHashSet</code>。</p>
</li>
<li><p><code>sorted</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore).reversed().thenComparing(Student::getName))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>sorted</code> 也是一个有状态的中间操作，在处理过程中，需要在内部记录出现过的元素，与 <code>distinct</code> 不同的是，每碰到流中的一个元素，<code>distinct</code> 都能立即做出处理，要么过滤，要么马上传递给下一个操作，但 <code>sorted</code> 不能，它需要先排序，为了排序，它需要先在内部数组中保存碰到的每一个元素，到流结尾时，再对数组排序，然后再将排序后的元素逐个传递给流水线中的下一个操作。</p>
</li>
<li><p><code>skip/limit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .limit(<span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>skip</code> 跳过流中的 n 个元素，如果流中元素不足 n 个，返回一个空流，<code>limit</code> 限制流的长度。</p>
</li>
<li><p><code>peek</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .peek(System.out::println)</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>它返回的流与之前的流是一样的，没有变化，但它提供了一个 <code>Consumer</code>，会将流中的每一个元素传给该 <code>Consumer</code>。这个方法的主要目的是支持调试，可以使用该方法观察在流水线中流转的元素。</p>
</li>
<li><p><code>mapToLong/mapToInt/mapToDouble</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sum = students.stream()</span><br><span class="line">        .mapToDouble(Student::getScore)</span><br><span class="line">        .sum();</span><br></pre></td></tr></table></figure>

<p><code>map</code> 函数接受的参数是一个 <code>Function&lt;T, R&gt;</code>，为避免装箱 / 拆箱，提高性能。</p>
</li>
<li><p><code>flatMap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p><code>flatMap</code> 接受一个函数 <code>mapper</code>，将流中的每一个元素都转换为一个流 <code>Stream</code>，然后把新生成流的每一个元素传递给下一个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = Arrays.asList(<span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">"hello abc"</span>,</span><br><span class="line">        <span class="string">"457  ###"</span></span><br><span class="line">&#125;);</span><br><span class="line">List&lt;String&gt; words = lines.stream()</span><br><span class="line">        .flatMap(line -&gt; Arrays.stream(line.split(<span class="string">"\\s+"</span>)))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(words);</span><br><span class="line"><span class="comment">/// ::out:: [hello, abc, 457, ###]</span></span><br></pre></td></tr></table></figure>

<p>基本类型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DoubleStream <span class="title">flatMapToDouble</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends DoubleStream&gt; mapper)</span></span></span><br><span class="line"><span class="function">IntStream <span class="title">flatMapToInt</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends IntStream&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">flatMapToLong</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends LongStream&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><ul>
<li><p><code>max/min</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p><code>java.util.Optional</code> 是 Java 8 引入的一个新类，它是一个泛型容器类，内部只有一个类型为 <code>T</code> 的单一变量 <code>value</code>，可能为 <code>null</code>，也可能不为 <code>null</code>。<code>Optional</code> 用于准确地传递程序的语义，它清楚地表明，其代表的值可能为 <code>null</code>，程序员应该进行适当的处理。<code>Optional</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value 不为 null 时返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回实际的值，如果为 null，抛出异常 NoSuchElementException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果 value 不为 null，返回 value，否则返回 other</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 构建一个空的 Optional，value 为 null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 构建一个非空的 Optional, 参数 value 不能为 null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 构建一个 Optional，参数 value 可以为 null，也可以不为 null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>max/min</code> 的例子中，通过声明返回值为 <code>Optional</code>，我们就知道，具体的返回值不一定存在，这发生在流中不含任何元素的情况下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student = students.stream()</span><br><span class="line">        .max(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">        .get();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>count</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> above90Count = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>allMatch/anyMatch/noneMatch</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> allPass = students.stream()</span><br><span class="line">        .allMatch(t -&gt; t.getScore() &gt;= <span class="number">60</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>findFirst/findAny</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span> <span class="comment">// 找第一个</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span>   <span class="comment">// 随便找一个</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &lt; <span class="number">60</span>)</span><br><span class="line">        .findAny();</span><br><span class="line"><span class="keyword">if</span>(student.isPresent())&#123;</span><br><span class="line">    <span class="comment">// 不及格的学生....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forEach</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toArray</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()</span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student[] above90Arr = students.stream()</span><br><span class="line">        .filter(t -&gt; t.getScore() &gt; <span class="number">90</span>)</span><br><span class="line">        .toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">    BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一般不用。因为 <code>collect</code> 函数比 <code>reduce</code> 更为通用、强大和易用。</p>
</li>
</ul>
<h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>接口方法都是通用的。但并行流内部会使用多线程，线程个数一般与系统的 CPU 核数一样，以充分利用 CPU 的计算能力。并行流内部会使用 Java 7 引入的 <code>fork/join</code> 框架，简单来说，处理由 <code>fork</code> 和 <code>join</code> 两个阶段组成，<code>fork</code> 就是将要处理的数据拆分为小块，多线程按小块进行并行计算，<code>join</code> 就是将小块的计算结果进行合并。使用并行流，不需要任何线程管理的代码，就能实现并行。</p>
<h3 id="从-collect-谈起"><a href="#从-collect-谈起" class="headerlink" title="从 collect 谈起"></a>从 <code>collect</code> 谈起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>; <span class="comment">// 用于合并部分结果</span></span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// characteristics() 用于标示收集器的特征，Collector 接口的调用者可以利用这些特征进行一些优化</span></span><br><span class="line">    <span class="comment">// Characteristics 是一个枚举，有三个值：CONCURRENT, UNORDERED 和 IDENTITY_FINISH</span></span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>collect</code> 和 <code>Collector&lt;T, A, R&gt;</code> 交互得一般过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先调用工厂方法 supplier() 创建一个存放处理状态的容器 container，类型为 A</span></span><br><span class="line">A container = collector.supplier().get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后对流中的每一个元素 T t，调用累加器 accumulator，参数为累计状态 container 和当前元素 t</span></span><br><span class="line"><span class="keyword">for</span> (T t : data) collector.accumulator().accept(container, t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后调用 finisher 对累计状态容器 container 进行可能的调整，以及类型转换（A 转换为 R），并返回结果</span></span><br><span class="line"><span class="keyword">return</span> collector.finisher().apply(container);</span><br></pre></td></tr></table></figure>

<h4 id="容器收集类"><a href="#容器收集类" class="headerlink" title="容器收集类"></a>容器收集类</h4><ul>
<li><p><code>Collectors.toList()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID); <span class="comment">// CH_ID 是一个静态变量，只有一个特征 IDENTITY_FINISH，表示 finisher 没有什么事情可以做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Collectors.toSet()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_UNORDERED_ID);</span><br><span class="line">    <span class="comment">// CH_UNORDERED_ID 是一个静态变量，它的特征有两个</span></span><br><span class="line">    <span class="comment">// 一个是 IDENTITY_FINISH，表示返回结果即为 Supplier 创建的 HashSet</span></span><br><span class="line">    <span class="comment">// 另一个是 UNORDERED，表示收集器不会保留顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Collectors.toCollection</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>

<p><code>Collectors.toCollection</code> 是一个通用的容器收集器，可以用于任何 <code>Collection</code> 接口的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                               (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Collectors.toMap()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Double&gt; nameScoreMap = students.stream().collect(</span><br><span class="line">        Collectors.toMap(Student::getName, Student::getScore));</span><br><span class="line"></span><br><span class="line">Map&lt;String, Student&gt; byIdMap = students.stream().collect(</span><br><span class="line">        Collectors.toMap(Student::getId, t -&gt; t)); <span class="comment">// “t -&gt; t” 也可以表示为 “Function.identity()”</span></span><br><span class="line"></span><br><span class="line">Map&lt;String,Integer&gt; strLenMap = Stream.of(<span class="string">"abc"</span>,<span class="string">"hello"</span>,<span class="string">"abc"</span>).collect(</span><br><span class="line">        Collectors.toMap(Function.identity(), t -&gt; t.length(), (oldValue,value)-&gt;value)));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">    BinaryOperator&lt;U&gt; mergeFunction)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">    BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">    Supplier&lt;M&gt; mapSupplier) <span class="comment">// 在其它 toMap 中，mapSupplier 其实是 HashMap::new，可以改成别的</span></span><br></pre></td></tr></table></figure>

<p><code>toMap</code> 主要用于顺序流，对于并发流，<code>Collectors</code> 有专门的名称为 <code>toConcurrentMap</code> 的收集器</p>
</li>
</ul>
<h4 id="字符串收集器"><a href="#字符串收集器" class="headerlink" title="字符串收集器"></a>字符串收集器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = Stream.of(<span class="string">"abc"</span>, <span class="string">"年年"</span>, <span class="string">"hello"</span>).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(</span><br><span class="line">    CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID); <span class="comment">// CH_NOID 表示特征集为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组-groupingBy"><a href="#分组-groupingBy" class="headerlink" title="分组 groupingBy"></a>分组 <code>groupingBy</code></h3><h4 id="三种形式"><a href="#三种形式" class="headerlink" title="三种形式"></a>三种形式</h4><p><code>classifier</code> 是分组器，<code>mapFactory</code> 是返回 <code>Map</code> 的工厂方法，默认是 <code>HashMap::new</code>，<code>downstream</code> 表示下游收集器，下游收集器负责<strong>收集同一个分组</strong>内元素的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(</span><br><span class="line">                                      Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(</span><br><span class="line">                                      Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(</span><br><span class="line">                                      Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                      Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个存放结果的 Map</span></span><br><span class="line">Map map = mapFactory.get();</span><br><span class="line"><span class="keyword">for</span> (T t : data) &#123;</span><br><span class="line">    <span class="comment">// 对每一个元素，先分组</span></span><br><span class="line">    K key = classifier.apply(t);</span><br><span class="line">    <span class="comment">// 找存放分组结果的容器，如果没有，让下游收集器创建，并放到 Map 中</span></span><br><span class="line">    A container = map.get(key);</span><br><span class="line">    <span class="keyword">if</span> (container == <span class="keyword">null</span>) &#123;</span><br><span class="line">        container = downstream.supplier().get();</span><br><span class="line">        map.put(key, container);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将元素交给下游收集器收集</span></span><br><span class="line">    downstream.accumulator().accept(container, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用分组收集器的 finisher 方法，转换结果</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    entry.setValue(downstream.finisher().apply(entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br></pre></td></tr></table></figure>

<h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groups = students.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Student::getGrade));</span><br></pre></td></tr></table></figure>

<h3 id="常见收集器"><a href="#常见收集器" class="headerlink" title="常见收集器"></a>常见收集器</h3><h4 id="分组计数、最大值和最小值"><a href="#分组计数、最大值和最小值" class="headerlink" title="分组计数、最大值和最小值"></a>分组计数、最大值和最小值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()</span><br><span class="line"><span class="comment">// 计算最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="comment">// 计算最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; gradeCountMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade, counting()));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; wordCountMap =</span><br><span class="line">        Stream.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"abc"</span>, <span class="string">"hello"</span>).collect(</span><br><span class="line">                groupingBy(Function.identity(), LinkedHashMap::<span class="keyword">new</span>, counting()));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;Student&gt;&gt; topStudentMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade,</span><br><span class="line">                maxBy(Comparator.comparing(Student::getScore))));</span><br><span class="line"></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 为了直接得到 Student，可以使用 Collectors 的另一个收集器 collectingAndThen</span></span><br><span class="line"><span class="comment">// 在得到 Optional&lt;Student&gt; 后调用 Optional 的 get 方法</span></span><br><span class="line">Map&lt;String, Student&gt; topStudentMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade,</span><br><span class="line">                collectingAndThen(</span><br><span class="line">                        maxBy(Comparator.comparing(Student::getScore)),</span><br><span class="line">                        Optional::get)));</span><br></pre></td></tr></table></figure>

<h4 id="分组数值统计"><a href="#分组数值统计" class="headerlink" title="分组数值统计"></a>分组数值统计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求平均值，int 和 long 也有类似方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="comment">// 求和，long 和 double 也有类似方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)    </span><br><span class="line"><span class="comment">// 求多种汇总信息，int 和 double 也有类似方法</span></span><br><span class="line"><span class="comment">// LongSummaryStatistics 包括个数、最大值、最小值、和、平均值等多种信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<h4 id="分组的-map"><a href="#分组的-map" class="headerlink" title="分组的 map"></a>分组的 <code>map</code></h4><p>对于每个分组内的元素，我们感兴趣的可能不是元素本身，而是它的某部分信息，在 <code>Stream</code> API 中，<code>Stream</code> 有 <code>map</code> 方法，可以将元素进行转换，<code>Collectors</code> 也为分组元素提供了函数 <code>mapping</code>，下游收集器的不再是元素本身，而是应用转换函数 mapper 之后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(</span><br><span class="line">        Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">        Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeNameMap =</span><br><span class="line">        students.stream().collect(</span><br><span class="line">                groupingBy(Student::getGrade,</span><br><span class="line">                        mapping(Student::getName, toList())));</span><br></pre></td></tr></table></figure>

<h4 id="分组结果处理-filter-sort-skip-limit"><a href="#分组结果处理-filter-sort-skip-limit" class="headerlink" title="分组结果处理 (filter/sort/skip/limit)"></a>分组结果处理 (<code>filter/sort/skip/limit</code>)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, A, R, RR&gt; <span class="function">Collector&lt;T, A, RR&gt; <span class="title">collectingAndThen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher)</span></span></span><br></pre></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">        downstream.accumulator(),</span><br><span class="line">        downstream.combiner(),</span><br><span class="line">        downstream.finisher().andThen(finisher),</span><br><span class="line">        characteristics);</span><br></pre></td></tr></table></figure>

<p>应用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; collectingAndSort(</span><br><span class="line">        Collector&lt;T, ?, List&lt;T&gt;&gt; downstream,</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        r.sort(comparator);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap =</span><br><span class="line">        students.stream().collect(</span><br><span class="line">                groupingBy(Student::getGrade,</span><br><span class="line">                        collectingAndSort(toList(),</span><br><span class="line">                                Comparator.comparing(Student::getScore).reversed())));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; collectingAndFilter(</span><br><span class="line">        Collector&lt;T, ?, List&lt;T&gt;&gt; downstream,</span><br><span class="line">        Predicate&lt;T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> r.stream().filter(predicate).collect(Collectors.toList());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap =</span><br><span class="line">        students.stream().collect(</span><br><span class="line">                groupingBy(Student::getGrade,</span><br><span class="line">                        collectingAndFilter(toList(), t -&gt; t.getScore() &lt; <span class="number">60</span>)));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; collectingAndSkipLimit(</span><br><span class="line">        Collector&lt;T, ?, List&lt;T&gt;&gt; downstream, <span class="keyword">long</span> skip, <span class="keyword">long</span> limit) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> r.stream().skip(skip).limit(limit).collect(Collectors.toList());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap =</span><br><span class="line">        students.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">                .collect(groupingBy(Student::getGrade,</span><br><span class="line">                        collectingAndSkipLimit(toList(), <span class="number">0</span>, <span class="number">2</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>分组的一个特殊情况是分区，就是将流按 <code>true/false</code> 分为两个组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(</span><br><span class="line">        Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(</span><br><span class="line">        Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">        Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Double&gt; avgScoreMap = students.stream().collect(</span><br><span class="line">        partitioningBy(t -&gt; t.getScore() &gt;= <span class="number">60</span>, averagingDouble(Student::getScore)));</span><br></pre></td></tr></table></figure>

<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><p><code>groupingBy</code> 和 <code>partitioningBy</code> 都可以接受一个下游收集器，而下游收集器又可以是分组或分区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; multiGroup =</span><br><span class="line">        students.stream().collect(</span><br><span class="line">                groupingBy(Student::getGrade,</span><br><span class="line">                        partitioningBy(t -&gt; t.getScore() &gt;= <span class="number">60</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="大名鼎鼎的-CompletableFuture"><a href="#大名鼎鼎的-CompletableFuture" class="headerlink" title="大名鼎鼎的 CompletableFuture"></a>大名鼎鼎的 <code>CompletableFuture</code></h3><p>没有 <code>CompletableFuture</code> 的旧时代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Callable&lt;Integer&gt; externalTask = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> time = delayRandom(<span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executor.submit(externalTask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行异步任务</span></span><br><span class="line">    Future&lt;Integer&gt; asyncRet = callExternalService();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行其他任务 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，处理可能的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer ret = asyncRet.get();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Supplier&lt;Integer&gt; externalTask = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> time = delayRandom(<span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(externalTask, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emmmmm，没啥变化…</p>
<p><code>supplyAsync</code> 是一个静态方法，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有 executor，任务被谁执行呢？与系统环境和配置有关，一般来说，如果可用的 CPU 核数大于 2</span></span><br><span class="line"><span class="comment"> * 会使用 Java 7 引入的 Fork/Join 任务执行服务，即 ForkJoinPool.commonPool()</span></span><br><span class="line"><span class="comment"> * 该任务执行服务背后的工作线程数一般为 CPU 核数减 1，即 Runtime.getRuntime().availableProcessors() - 1</span></span><br><span class="line"><span class="comment"> * 否则，会使用 ThreadPerTaskExecutor，它会为每个任务创建一个线程</span></span><br><span class="line"><span class="comment"> * 对于 CPU 密集型的运算任务，使用 Fork/Join 任务执行服务是合适的</span></span><br><span class="line"><span class="comment"> * 但对于一般的调用外部服务的异步任务，Fork/Join 可能是不合适的，因为它的并行度比较低</span></span><br><span class="line"><span class="comment"> * 可能会让本可以并发的多任务串行运行，这时，应该提供 Executor 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>类似接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="CompletableFuture-对-Future-的增强"><a href="#CompletableFuture-对-Future-的增强" class="headerlink" title="CompletableFuture 对 Future 的增强"></a><code>CompletableFuture</code> 对 <code>Future</code> 的增强</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join 与 get 方法类似，也会等待任务结束，但它不会抛出受检异常，而是包装为运行时异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// Future 有 isDone 方法检查任务是否结束了，但不知道任务是正常结束还是异常结束</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompletedExceptionally</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// getNow 与 join 类似，但如果没拿到结果，它不会等待，而是会返回传入的参数 valueIfAbsent</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span></span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 和 <code>FutureTask</code> 类似，可以直接创建线程执行它们，而不是非要用什么 <code>Executor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(externalTask);</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            future.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.complete(externalTask.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                future.completeExceptionally(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流式响应"><a href="#流式响应" class="headerlink" title="流式响应"></a>流式响应</h4><ol>
<li><p><code>whenComplete</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * whenComplete 注册的函数具体由谁执行要看注册时任务的状态</span></span><br><span class="line"><span class="comment"> * 如果注册时任务还没有结束，则注册的函数会由执行任务的线程执行，在该线程执行完任务后执行注册的函数</span></span><br><span class="line"><span class="comment"> * 如果注册时任务已经结束了，则由当前线程 (即调用注册函数的线程) 执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CompletableFuture.supplyAsync(externalTask).whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).join();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Executor executor)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>handle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ret =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);</span><br><span class="line">    &#125;).handle((result, ex)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(ret);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exceptionally</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="依赖单一阶段的任务流"><a href="#依赖单一阶段的任务流" class="headerlink" title="依赖单一阶段的任务流"></a>依赖单一阶段的任务流</h4><ol>
<li><p><code>thenRun</code></p>
<p>在 <code>thenRun</code> 构建的任务流中，只有前一个阶段没有异常结束，下一个阶段的任务才会执行，如果前一个阶段发生了异常，所有后续阶段都不会运行，结果会被设为相同的异常，调用 join 会抛出运行时异常 <code>CompletionException</code>。</p>
<p><code>thenRun</code> 指定的下一个任务类型是 <code>Runnable</code>，它不需要前一个阶段的结果作为参数，也没有返回值，所以，在 <code>thenRun</code> 返回的 <code>CompletableFuture</code> 中，结果类型为 <code>Void</code>，即没有结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable taskA = () -&gt; System.out.println(<span class="string">"task A"</span>);</span><br><span class="line">Runnable taskB = () -&gt; System.out.println(<span class="string">"task B"</span>);</span><br><span class="line">Runnable taskC = () -&gt; System.out.println(<span class="string">"task C"</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(taskA)</span><br><span class="line">        .thenRun(taskB)</span><br><span class="line">        .thenRun(taskC)</span><br><span class="line">        .join();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thenAccept</code>/<code>thenApply</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">"hello"</span>;</span><br><span class="line">Function&lt;String, String&gt; taskB = (t) -&gt; t.toUpperCase();</span><br><span class="line">Consumer&lt;String&gt; taskC = (t) -&gt; System.out.println(<span class="string">"consume: "</span> + t);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(taskA)</span><br><span class="line">        .thenApply(taskB)</span><br><span class="line">        .thenAccept(taskC)</span><br><span class="line">        .join();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>thenCompose</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">"hello"</span>;</span><br><span class="line">Function&lt;String, CompletableFuture&lt;String&gt;&gt; taskB = (t) -&gt;</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; t.toUpperCase());</span><br><span class="line">Consumer&lt;String&gt; taskC = (t) -&gt; System.out.println(<span class="string">"consume: "</span> + t);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(taskA)</span><br><span class="line">        .thenCompose(taskB)</span><br><span class="line">        .thenAccept(taskC)</span><br><span class="line">        .join();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="依赖两个阶段的任务流"><a href="#依赖两个阶段的任务流" class="headerlink" title="依赖两个阶段的任务流"></a>依赖两个阶段的任务流</h4><ol>
<li><p>依赖两个都完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;?&gt; other, </span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="function"><span class="params">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">"taskA"</span>;</span><br><span class="line">CompletableFuture&lt;String&gt; taskB = CompletableFuture.supplyAsync(() -&gt; <span class="string">"taskB"</span>);</span><br><span class="line">BiFunction&lt;String, String, String&gt; taskC = (a, b) -&gt; a + <span class="string">","</span> + b;</span><br><span class="line"></span><br><span class="line">String ret = CompletableFuture.supplyAsync(taskA)</span><br><span class="line">        .thenCombineAsync(taskB, taskC)</span><br><span class="line">        .join();</span><br><span class="line">System.out.println(ret);</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖任意一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;?&gt; other, </span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;? extends T&gt; other, </span></span></span><br><span class="line"><span class="function"><span class="params">        Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        CompletionStage&lt;? extends T&gt; other, </span></span></span><br><span class="line"><span class="function"><span class="params">        Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="依赖多个阶段的任务流"><a href="#依赖多个阶段的任务流" class="headerlink" title="依赖多个阶段的任务流"></a>依赖多个阶段的任务流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>

<p>它们是静态方法，基于多个 <code>CompletableFuture</code> 构建了一个新的 <code>CompletableFuture</code>。</p>
<p>对于 <code>allOf</code>，当所有子 <code>CompletableFuture</code> 都完成时，它才完成，如果有的 <code>CompletableFuture</code> 异常结束了，则新的 <code>CompletableFuture</code> 的结果也是异常，不过，它并不会因为有异常就提前结束，而是会等待所有阶段结束，如果有多个阶段异常结束，新的 <code>CompletableFuture</code> 中保存的异常是最后一个的。新的 <code>CompletableFuture</code> 会持有异常结果，但不会保存正常结束的结果，如果需要，可以从每个阶段中获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; taskA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"helloA"</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; taskB = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; taskC = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">30</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"task C exception"</span>);</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture.allOf(taskA, taskB, taskC).whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!taskA.isCompletedExceptionally()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"task A "</span> + taskA.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于 <code>anyOf</code> 返回的 <code>CompletableFuture</code>，当第一个子 <code>CompletableFuture</code> 完成或异常结束时，它相应地完成或异常结束，结果与第一个结束的子 <code>CompletableFuture</code> 一样。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" rel="tag"># Java 编程的逻辑</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/20/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="prev" title="反射、注解、代理和类加载机制">
      <i class="fa fa-chevron-left"></i> 反射、注解、代理和类加载机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/02/24/Redis-%E5%AE%9E%E6%88%98/" rel="next" title="Redis 实战">
      Redis 实战 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#从内部类到-Lambda"><span class="nav-text">从内部类到 Lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量问题"><span class="nav-text">变量问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语法糖之虞"><span class="nav-text">语法糖之虞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式接口"><span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义函数式接口"><span class="nav-text">预定义函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate-示例"><span class="nav-text">Predicate 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-示例"><span class="nav-text">Function 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer-示例"><span class="nav-text">Consumer 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法引用"><span class="nav-text">方法引用 ::</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法"><span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例方法"><span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过变量引用方法"><span class="nav-text">通过变量引用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的复合"><span class="nav-text">函数的复合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator-中的复合方法"><span class="nav-text">Comparator 中的复合方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-function-中的复合方法"><span class="nav-text">java.util.function 中的复合方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-漫谈"><span class="nav-text">Stream 漫谈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本示例"><span class="nav-text">基本示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间操作"><span class="nav-text">中间操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终端操作"><span class="nav-text">终端操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行流"><span class="nav-text">并行流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-collect-谈起"><span class="nav-text">从 collect 谈起</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器收集类"><span class="nav-text">容器收集类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串收集器"><span class="nav-text">字符串收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组-groupingBy"><span class="nav-text">分组 groupingBy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三种形式"><span class="nav-text">三种形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本原理"><span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用法示例"><span class="nav-text">用法示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见收集器"><span class="nav-text">常见收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分组计数、最大值和最小值"><span class="nav-text">分组计数、最大值和最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组数值统计"><span class="nav-text">分组数值统计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组的-map"><span class="nav-text">分组的 map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组结果处理-filter-sort-skip-limit"><span class="nav-text">分组结果处理 (filter&#x2F;sort&#x2F;skip&#x2F;limit)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区"><span class="nav-text">分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多级分组"><span class="nav-text">多级分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大名鼎鼎的-CompletableFuture"><span class="nav-text">大名鼎鼎的 CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture-对-Future-的增强"><span class="nav-text">CompletableFuture 对 Future 的增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流式响应"><span class="nav-text">流式响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖单一阶段的任务流"><span class="nav-text">依赖单一阶段的任务流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖两个阶段的任务流"><span class="nav-text">依赖两个阶段的任务流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖多个阶段的任务流"><span class="nav-text">依赖多个阶段的任务流</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xijinian"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">xijinian</p>
  <div class="site-description" itemprop="description">放轻松，就像在漫游地球～</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://twitter.com/xijinian" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;xijinian" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/xijinian" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;xijinian" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xijinian</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://xijinian.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.xijinian.top/2019/01/23/Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/";
    this.page.identifier = "2019/01/23/Java-8-函数式编程/";
    this.page.title = "Java 8 函数式编程";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://xijinian.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
